import meta from '../package.json';

import { createReadStream, promises as fs } from 'fs';
import cyclic32 from 'cyclic-32';
import ora from 'ora';
import terminalLink from 'terminal-link';
import chalk from 'chalk';

import { DateObject, SFVObject } from '../types/util';

function bufferToString(inputBuffer: Buffer): string {
  const outputString = [];

  inputBuffer.forEach(item =>
    outputString.push(
      item
        .toString(16)
        .toUpperCase()
        .padStart(2, '0')
    )
  );

  return outputString.join('');
}

async function checksumFromStream(stream: NodeJS.ReadableStream): Promise<string> {
  return new Promise((resolve, reject) => {
    stream
      .pipe( cyclic32.createHash() )
      .on('error', (err) => reject(err))
      .on('data', buffer => resolve(buffer.toString('hex').toUpperCase()));
  });
}

async function checksumFromFile(inputFile: string): Promise<string> {
  await fs.access(inputFile);

  return await checksumFromStream(createReadStream(inputFile));
}

async function compareSFV(sfvFiles: string[], failFast = false): Promise<void> {
  console.log('\nVerifying files:');

  await Promise.all( sfvFiles.map(async sfvFile => {
    const sfvContents = await readSFV(sfvFile);

    await Promise.all(sfvContents.map(async ({file, crc32}) => {
      const spinner = ora(file).start();
      let actualCRC;

      try {
         actualCRC = await checksumFromFile(file);
      } catch (e) {
        spinner.fail(`${file} ${chalk.red(crc32)} ${chalk.dim(e)}`);

        if (failFast) {
          throw 'Failing fast'
        } else {
          return;
        }
      }

      if (crc32 === actualCRC) {
        spinner.succeed(`${file} ${chalk.blue(crc32)}`);
      } else {
        spinner.fail(`${file} ${chalk.red(crc32)} (actual: ${chalk.blue(actualCRC)})`);

        if (failFast) throw 'Failing fast';
      }
    }));
  }));
}

function detectHash(algorithm: string): string {
  switch (algorithm.length) {
    case 8:
      return 'crc32';

    case 32:
      return 'md5';

    case 40:
      return 'sha1';

    case 64:
      return 'sha256';

    case 128:
      return 'sha512';

    default:
      throw Error('Unsupported hashing algorithm');
  }
}

async function calculateChecksum(files: string[], printOutput: boolean, failFast: boolean): Promise<string[]> {
  if (!printOutput) {
    const checksum = (files.length === 1)
      ? 'checksum'
      : 'checksums';

    console.log(`\nCalculating ${checksum}:`);
  }

  return await Promise.all(files.map( async file => {
    let spinner;
    let checksum;

    if (!printOutput) {
      spinner = ora(`${file}`).start();
    }

    try {
      checksum = await checksumFromFile(file);
      if (!printOutput) spinner.succeed(`${file} ${chalk.blue(checksum)}`);
    } catch (e) {
      if (failFast) {
        spinner.fail(`${file} ${chalk.dim(e)}`)
        softThrowError('Failing fast to error', true);
      }
      if (!printOutput) spinner.fail(`${file} ${chalk.dim(e)}`);
    }

    return `${file} ${checksum}`;
  }));
}

function getDate(): DateObject {
  const date = new Date();

  return {
    year: date.getFullYear().toString(),
    month: date.getMonth().toString().padStart(2, '0'),
    day: date.getMonth().toString().padStart(2, '0'),
    hours: date.getHours().toString().padStart(2, '0'),
    minutes: date.getMinutes().toString().padStart(2, '0'),
    seconds: date.getSeconds().toString().padStart(2, '0')
  }
}

function isSupportedAlgorithm(algorithm: string): boolean {
  return ['md5', 'sha1', 'sha256', 'sha512'].includes(algorithm.replace('-', '').toLowerCase());
}

function parseSFV(input: string | string[]): SFVObject[] {
  const lines = Array.isArray(input)
    ? stripComments(input)
    : stripComments(input.split('\n'));

  return lines.map(line => {
    const [file, crc32] = line
      .trim()
      .split(/^(.*)\s+(\w{8})$/g)
      .filter(item => item);

    return file && crc32
      ? {
        file,
        crc32
      }
      : null;
  }).filter(item => item);
}

function printTitle(): void {
  const title = `${meta.name} v${meta.version}`;
  const linkedTitle = terminalLink(title, meta.homepage, {
      fallback() {
        return `${title} | ${meta.homepage}`;
      }
    });

  console.log(linkedTitle);
}

async function readSFV(filePath: string): Promise<SFVObject[]> {
  const fileContents = (await fs.readFile(filePath)).toString();

  return parseSFV(fileContents.toString());
}

function setComment(useWinSFV: boolean): string {
  const {
    year, month, day,
    hours, minutes, seconds
  } = getDate();

  return useWinSFV
    ? `; Generated by WIN-SFV32 v1.1a on ${year}-${month}-${day} at ${hours}:${minutes}.${seconds}\r\n;`
    : `; ${meta.name} v${meta.version} | ${meta.homepage}\n;`;
}

function softThrowError(message: string, newLine = false): void {
  process.on('exit', () => {
    message = newLine
      ? `\nðŸ”¥ ${message}`
      : `ðŸ”¥ ${message}`;

    console.log(message);
  });

  process.exit();
}

function stripComments(lines: string[]): string[] {
  return lines.filter(line =>
    !line
      .trim()
      .startsWith(';')
  )
}

async function writeSFV(fileName: string, fileContents: string): Promise<void> {
  const outputFile = fileName.endsWith('.sfv')
    ? fileName
    : `${fileName}.sfv`;

  console.log('\nWriting output:');
  const spinner = ora(outputFile).start();

  try {
    await fs.writeFile(outputFile, fileContents);
    spinner.succeed(outputFile);
  } catch (e) {
    spinner.fail(`${outputFile} ${chalk.dim(e)}`);
  }
}

export {
  bufferToString,
  calculateChecksum,
  compareSFV,
  checksumFromFile,
  checksumFromStream,
  getDate,
  isSupportedAlgorithm,
  parseSFV,
  printTitle,
  readSFV,
  setComment,
  stripComments,
  softThrowError,
  writeSFV
};
